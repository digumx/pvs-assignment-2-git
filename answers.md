## Question A.1:
### Part a:

The required proof is saved into `sum_plus.prf` as `sum_of_squares_1`.

### Part b:

The automated proof is saved into `sum_plus.prf` as `sum_of_squares_auto`.

### Part c:

Replacing the `(auto_rewrite_defs)` with `(auto_rewrite_theory "sum_plus")` in `sum_of_squares` did successfully prove the
lemma in my case. The rewrite rules generated included all rewrite rules generated by the original `(auto_rewrite_defs)`,
and also had an extra rewrite rule pertaining to the lemma `sum_plus`.

### Part d:

Since the proof worked, no modification was needed.

## Question B.1:
### Part a:

The command `(assert)` fails because internally it uses the PVS desicion procedures, and to add the formulae in the 
sequent to the internal efficient data structure of true assumption maintained by the desicion procedures it uses
`(record)`. However, `(record)` does not work for recursive `IF` structures without simplification. Internally `(assert)`
uses `(simplify)` to simplify the formulae in the sequent, which can only remove one level of `IF` if it is able to 
resolve the condition to `TRUE`, `FALSE`, or if the condition is already recorded. In the current case no such 
simplifications are possible, and a case split is necessary, and thus `(simplify)` fails to simplify the formulae, and
`(record)` fails to record them. Essencially, assert can simplify propositional expressions only if no case splitting
is necessary because one or more of the predicates can be simplified to truth values. This does not happens in this case,
and so `(assert)` fails.

### Part b:

The command `(split)` fails because split can only split the sequent if there is a formula with a top level disunction,
that is, a formula with `IF` at the top level, an antecedent with `OR` or `IMPLIES` at the top level or a consequent with
`AND` or `<=>` at the top level. The top level construct of the only formula in the sequent in this case is `=`, and so
`(split)` fails.

The recursive definintion of `(prop)` simply tries `(flatten)` and `(split)` repeatedly to recursively remove top level 
propositional connectives in the goal. In this case, the goal has no top level propositional connective, and `(split)`
or `(flatten)` has no effect. Thus, `(prop)` fails.

The command `(ground)` performs propositional simplifications followed by further simplifications performed by `(assert)`.
As the top level connective in the only formula in the sequent is not propositional, no propositional simplification is
possible. We have also seen that `(assert)` itself fails in this case, and thus `(ground)` produces no change.

### Part c:

The required manual proof using `(case)` is saved as `iflemma-1`. The number of case splits was minimised by spliting into 
cases according to the conditions on the right hand side, that is, each condition in the right hand `IF` is a case. This
was achieved by applying case on the disjunction of all the conditions disjuncted with the negation of the conjunction of
all the conditions. The negation term in above was computed by hand. This produces a total of 6 cases.

### Part d:

We note that expressions of the form `F(IF A THEN B ELSE C)` can be transformed so that the top level connective is `IF` by
"lifting" the `IF`, transforming the expression to `IF A THEN F(B) ELSE F(C)`. The `(lift-if)` command looks at all the 
leftmost `IF` connectives in a formula and selects the innermost one to apply the lifting transformation to it.

### Part e:

Applying the `(lift-if)` command lifts all the `IF` conditions on the left of the `=` to above the `=`, transforming the
formula from the form:

```
(IF z = y
         THEN (IF w = v THEN 5
               ELSIF z = x THEN (IF w = u THEN 3 ELSE f(z) ENDIF)
               ELSE f(z)
               ENDIF)
       ELSIF z = x THEN 3
       ELSE f(z)
       ENDIF) = R
```

to the form:

```
(IF z = y
         THEN (IF w = v THEN 5 = R
               ELSIF z = x THEN (IF w = u THEN 3 = R
                                          ELSE f(z) = R
                                          ENDIF)
               ELSE f(z) = R
               ENDIF)
       ELSIF z = x THEN 3 = R
       ELSE f(z) = R
       ENDIF)
```

so that the top level connectives some depth are now `IF`. The command also substitutes `TRUE` or `FALSE` into the instances
of the boolean expression the lifted ifs branch on within the copied instances of `R` depending on which branch of the lifted 
if the instance of `R` lies in. Applying `(ground)` proves the resulting formula. This proof is saved as `iflemma-liftif`.

The command `(lift-if * )` has the exact same effect as `(lift-if)`, and exactly as before the proof can be completed with
`(ground)`. This proof is saved as `iflemma-liftif-star`.

### Part f:

As we saw in the proof of `iflemma`, applying `(lift-if)` to the initial sequent in the proof of `iflemma1` lifts the `IF` to 
the left of the `=` above the `=`, transforming the formula in a manner very similar to how the formula was transformed while
proving `iflemma`. Similar to the previous case, the decision condition expressions for the `IF` in the right hand are substituted
according to which branch the instance of the right hand expression belongs. Applying `(ground)` on the transformed formula
completes the proof, as before. This proof is saved as `iflemma1-1`.

## Problem C.1:
### Part 1:

The `(auto-rewrite-defs)` installs rewrite rules automatically for the definitions of the structural ordering for `aexpt` and
`bexpt`, which comes from an expanded definition defining when an instance of these expression types is structurally smaller
than another. It also installs rewrite rules for the definitions of the functions `aeval` and `Minus`. Additionally, several 
rewrite rules for definitions relevant to proving well-foundedness and totally-orderedness of the order used in the measure
function are also installed. Once the following `(skosimp*)` command reduces the sequent to a form with no quantifiers or 
implications in the goal, the installed rewrite rules are available to `(assert)` which can then use them to automatically
simplify and evaluate the left hand side of the lemma. Even if the form of the arguement to `aeval` is changed, the proof
need not be changed, as the `assert` command automatically evaluates the left hand side regardless of it's form.

### Part 2:

For the `optprop-1` proof, the proof begins by installing auto rewrites corresponding to all cases of the recursive datatypes
and functions with `(auto-rewrite-defs)` and begins an induction on `a`, which is an instance of the inductive datatype `aexpt`. 
This produces 4 subgoals, one for base `ANum` case, and 3 for the other 3 inductive cases. For the first subgoal, `(skosimp*)` 
removes quantifiers and `(assert)` uses auto rewrites to automatically simplify and prove the goal. `(skosimp*)` is used on
the `APlus` case to remove quantifiers, `(assert)` to rewrite using definitions of `Optimize` and `aeval` and then `(lift-if)`
is used to lift the if above the equality so that it is the topmost connective. Then the resulting goal is of the correct form
so that `(assert)` may be used to prove it using the desicion procedures for arithmatic simplification and by rewriting it 
using the available definitions. For the other two cases, the same strategy as the one used in the firs case works, that is, 
using `(skosimp*)` to remove quantifires and implications in the goal, followed by proving the goal using rewrites and 
simplification via the `(assert)` command.

For the `optprop-2` proof, we start as before by installing rewrite rules for necessary definitions via `(auto-rewrite-defs)`
and beginning an induction on `a`, splitting into 4 goals as before. Then, for each goal, we use `(skosimp*)` to remove 
quantifiers and implications, and then apply `(smash)` on it. While `(assert)` can only rewrite based on installed rules and
perform arithmatic simplifications and propositional simplifications when the arguements to the conditionals can be resolved 
to `TRUE` or `FALSE`, `(smash)` repeatedly applies `(bddsimp)` to perform more sophisticated propositional simplification, 
`(lift-if)` to reduce a formula in an equational form to a propositional form, and `(assert)` to perform arithmatic simplification
and rewrites to simplify predicates to truth values. Since in the original proof we saw that a combination of `(assert)` and
`(lift-if)` was sufficient to complete the proof for each of the cases, `(smash)` completes the proof in each case.

We notice in the previous proof that the same commands are being applied in each subgoal generated by the induction. The proof
`optprop-2` uses the strategies `try` and `then` to automate this process. `(try (step1) (step2) (step3))` attempts `(step1)`,
and if it produces more subgoals, applies `(step2)` on the generated subgoals, else if it fails or acts like `(skip)` and
produces no further subgoals, it applies `(step3)` to the original goal. `(then (step1) (step2) ...)` simply applies `(step1)`
to the first goal, then applies `(step2)` to all resulting subgoals and so on. Note that if `(step1)` fails, there is only one
resulting subgoal, which is the original subgoal. Thus, `(step2)` will then act on the original subgoal. The proof uses
`(try (induct "a") (then (skosimp*) (smash)) (skip))`, where the outer `try` attempts induction on `a`, failing which `(skip)`
is called. In this case however, the induction succeeds and `(then (skosimp*) (smash))` is applied to each subgoal generated,
which simply invokes `(skosimp*)` followed by `(smash)` on each subgoal as seen in the previous proof, completing the proof.

### Part 3:

There were no unproved TCCs.

## Problem C.2:

The required completions were made in `opsemwithstates4class.pvs`. For the datatype `aexpt`, expressions `AConst(n)` represent
a constant `nat` and `AVar(v)` represent reading a variable `v`, the other constructors have the exact same meaning as in 
`opsem.pvs`. For `bexpt`, additional constructors representing the comparision `<` and the connective `OR` were added. The `aeval`
and `beval` functions recursively evaluate arithmatic and boolean expressions by performing substitutions from a given state. The
function `Opt` optimizes expressions recursively by first optimising each of the left and right subexpressions and then reducing
the resulting expression using the following identities:

```
FORALL x: aexpt
    0 + x = x
    x + 0 = x
    0 - x = 0
    x - 0 = l
    0 * x = 0
    x * 0 = 0
    1 * x = l
    x * 1 = x
```

The theorem `Opt_sound` states that `Opt` is sound, that is, optimizing any arithmatic expression with respect to any state and
then evaluating it with respect to the same state produces the same value as directly evaluating the expression with respect to
the state.

All TCCs generated are manually proved and the proofs are saved under PVS's default names `<tcc_name>-1`, where `<tcc_name>`
represents the name of the TCC generated.
