## Question A.1:
### Part a:

The required proof is saved into `sum_plus.prf` as `sum_of_squares_1`.

### Part b:

The automated proof is saved into `sum_plus.prf` as `sum_of_squares_auto`.

### Part c:

Replacing the `(auto_rewrite_defs)` with `(auto_rewrite_theory "sum_plus")` in `sum_of_squares` did successfully prove the
lemma in my case. The rewrite rules generated included all rewrite rules generated by the original `(auto_rewrite_defs)`,
and also had an extra rewrite rule pertaining to the lemma `sum_plus`.

### Part d:

Since the proof worked, no modification was needed.

## Question B.1:
### Part a:

The command `(assert)` fails because internally it uses the PVS desicion procedures, and to add the formulae in the 
sequent to the internal efficient data structure of true assumption maintained by the desicion procedures it uses
`(record)`. However, `(record)` does not work for recursive `IF` structures without simplification. Internally `(assert)`
uses `(simplify)` to simplify the formulae in the sequent, which can only remove one level of `IF` if it is able to 
resolve the condition to `TRUE`, `FALSE`, or if the condition is already recorded. In the current case no such 
simplifications are possible, and a case split is necessary, and thus `(simplify)` fails to simplify the formulae, and
`(record)` fails to record them. Essencially, assert can simplify propositional expressions only if no case splitting
is necessary because one or more of the predicates can be simplified to truth values. This does not happens in this case,
and so `(assert)` fails.

### Part b:

The command `(split)` fails because split can only split the sequent if there is a formula with a top level disunction,
that is, a formula with `IF` at the top level, an antecedent with `OR` or `IMPLIES` at the top level or a consequent with
`AND` or `<=>` at the top level. The top level construct of the only formula in the sequent in this case is `=`, and so
`(split)` fails.

The recursive definintion of `(prop)` simply tries `(flatten)` and `(split)` repeatedly to recursively remove top level 
propositional connectives in the goal. In this case, the goal has no top level propositional connective, and `(split)`
or `(flatten)` has no effect. Thus, `(prop)` fails.

The command `(ground)` performs propositional simplifications followed by further simplifications performed by `(assert)`.
As the top level connective in the only formula in the sequent is not propositional, no propositional simplification is
possible. We have also seen that `(assert)` itself fails in this case, and thus `(ground)` produces no change.

### Part c:

The required manual proof using `(case)` is saved as `iflemma-1`. The number of case splits was minimised by spliting into 
cases according to the conditions on the right hand side, that is, each condition in the right hand `IF` is a case. This
was achieved by applying case on the disjunction of all the conditions disjuncted with the negation of the conjunction of
all the conditions. The negation term in above was computed by hand. This produces a total of 6 cases.

### Part d:

We note that expressions of the form `F(IF A THEN B ELSE C)` can be transformed so that the top level connective is `IF` by
"lifting" the `IF`, transforming the expression to `IF A THEN F(B) ELSE F(C)`. The `(lift-if)` command looks at all the 
leftmost `IF` connectives in a formula and selects the innermost one to apply the lifting transformation to it.

### Part e:

Applying the `(lift-if)` command lifts all the `IF` conditions on the left of the `=` to above the `=`, transforming the
formula from the form:

```
(IF z = y
         THEN (IF w = v THEN 5
               ELSIF z = x THEN (IF w = u THEN 3 ELSE f(z) ENDIF)
               ELSE f(z)
               ENDIF)
       ELSIF z = x THEN 3
       ELSE f(z)
       ENDIF) = R
```

to the form:

```
(IF z = y
         THEN (IF w = v THEN 5 = R
               ELSIF z = x THEN (IF w = u THEN 3 = R
                                          ELSE f(z) = R
                                          ENDIF)
               ELSE f(z) = R
               ENDIF)
       ELSIF z = x THEN 3 = R
       ELSE f(z) = R
       ENDIF)
```

so that the top level connectives some depth are now `IF`. The command also substitutes `TRUE` or `FALSE` into the instances
of the boolean expression the lifted ifs branch on within the copied instances of `R` depending on which branch of the lifted 
if the instance of `R` lies in. Applying `(ground)` proves the resulting formula. This proof is saved as `iflemma-liftif`.

The command `(lift-if * )` has the exact same effect as `(lift-if)`, and exactly as before the proof can be completed with
`(ground)`. This proof is saved as `iflemma-liftif-star`.

### Part f:

As we saw in the proof of `iflemma`, applying `(lift-if)` to the initial sequent in the proof of `iflemma1` lifts the `IF` to 
the left of the `=` above the `=`, transforming the formula in a manner very similar to how the formula was transformed while
proving `iflemma`. Similar to the previous case, the decision condition expressions for the `IF` in the right hand are substituted
according to which branch the instance of the right hand expression belongs. Applying `(ground)` on the transformed formula
completes the proof, as before. This proof is saved as `iflemma1-1`.

## Problem C.1:
### Part 1:

The `(auto-rewrite-defs)` installs rewrite rules automatically for the definitions of the structural ordering for `aexpt` and
`bexpt`, which comes from an expanded definition defining when an instance of these expression types is structurally smaller
than another. It also installs rewrite rules for the definitions of the functions `aeval` and `Minus`. Additionally, several 
rewrite rules for definitions relevant to proving well-foundedness and totally-orderedness of the order used in the measure
function are also installed. Once the following `(skosimp*)` command reduces the sequent to a form with no quantifiers or 
implications in the goal, the installed rewrite rules are available to `(assert)` which can then use them to automatically
simplify and evaluate the left hand side of the lemma. Even if the form of the arguement to `aeval` is changed, the proof
need not be changed, as the `assert` command automatically evaluates the left hand side regardless of it's form.

### Part 2:

For the `optprop-1` proof, the proof begins by installing auto rewrites corresponding to all cases of the recursive datatypes
and functions with `(auto-rewrite-defs)` and begins an induction on `a`, which is an instance of the inductive datatype `aexpt`. 
This produces 4 subgoals, one for base `ANum` case, and 3 for the other 3 inductive cases. For the first subgoal, `(skosimp*)` 
removes quantifiers and `(assert)` uses auto rewrites to automatically simplify and prove the goal. `(skosimp*)` is used on
the `APlus` case to remove quantifiers, `(assert)` to rewrite using definitions of `Optimize` and `aeval` and then `(lift-if)`
is used to lift the if above the equality so that it is the topmost connective. Then the resulting goal is of the correct form
so that `(assert)` may be used to prove it using the desicion procedures for arithmatic simplification and by rewriting it 
using the available definitions. For the other two cases, the same strategy as the one used in the firs case works, that is, 
using `(skosimp*)` to remove quantifires and implications in the goal, followed by proving the goal using rewrites and 
simplification via the `(assert)` command.

For the `optprop-2` proof, we start as before by installing rewrite rules for necessary definitions via `(auto-rewrite-defs)`
and beginning an induction on `a`, splitting into 4 goals as before. Then, for each goal, we use `(skosimp*)` to remove 
quantifiers and implications, and then apply `(smash)` on it. While `(assert)` can only rewrite based on installed rules and
perform arithmatic simplifications and propositional simplifications when the arguements to the conditionals can be resolved 
to `TRUE` or `FALSE`, `(smash)` repeatedly applies `(bddsimp)` to perform more sophisticated propositional simplification, 
`(lift-if)` to reduce a formula in an equational form to a propositional form, and `(assert)` to perform arithmatic simplification
and rewrites to simplify predicates to truth values. Since in the original proof we saw that a combination of `(assert)` and
`(lift-if)` was sufficient to complete the proof for each of the cases, `(smash)` completes the proof in each case.

We notice in the previous proof that the same commands are being applied in each subgoal generated by the induction. The proof
`optprop-2` uses the strategies `try` and `then` to automate this process. `(try (step1) (step2) (step3))` attempts `(step1)`,
and if it produces more subgoals, applies `(step2)` on the generated subgoals, else if it fails or acts like `(skip)` and
produces no further subgoals, it applies `(step3)` to the original goal. `(then (step1) (step2) ...)` simply applies `(step1)`
to the first goal, then applies `(step2)` to all resulting subgoals and so on. Note that if `(step1)` fails, there is only one
resulting subgoal, which is the original subgoal. Thus, `(step2)` will then act on the original subgoal. The proof uses
`(try (induct "a") (then (skosimp*) (smash)) (skip))`, where the outer `try` attempts induction on `a`, failing which `(skip)`
is called. In this case however, the induction succeeds and `(then (skosimp*) (smash))` is applied to each subgoal generated,
which simply invokes `(skosimp*)` followed by `(smash)` on each subgoal as seen in the previous proof, completing the proof.

### Part 3:

The manual proofs for the TCCs are saved as `<TCC_name>-manual`, where `<TCC_name>` represents the name of the TCC as it appers
in the output of `M-x show-tccs`. For all the TCCs, after installing rewrites, skolemizing and flattening, rewriting with the 
equality in the hypothesis and applying `(assert)` completes the proof.

## Problem C.2:

The required completions were made in `opsemwithstates4class.pvs`. For the datatype `aexpt`, expressions `AConst(n)` represent
a constant `nat` and `AVar(v)` represent reading a variable `v`, the other constructors have the exact same meaning as in 
`opsem.pvs`. For `bexpt`, additional constructors representing the comparision `<` and the connective `OR` were added. The `aeval`
and `beval` functions recursively evaluate arithmatic and boolean expressions by performing substitutions from a given state. The
function `Opt` optimizes expressions recursively by first optimising each of the left and right subexpressions and then reducing
the resulting expression using the following identities:

```
FORALL x: aexpt
    0 + x = x
    x + 0 = x
    0 - x = 0
    x - 0 = l
    0 * x = 0
    x * 0 = 0
    1 * x = l
    x * 1 = x
```
The identities involving `-`, implemented as the function `Minus`, are stated and proved in the lemmas `Minus_0` and `Minus_from_0`.

The theorem `Opt_sound` states that `Opt` is sound, that is, optimizing any arithmatic expression with respect to any state and
then evaluating it with respect to the same state produces the same value as directly evaluating the expression with respect to
the state.

All TCCs generated are manually proved and the proofs are saved under PVS's default names `<tcc_name>-1`, where `<tcc_name>`
represents the name of the TCC generated.

All lemmas and theorems have been proved and the proofs saved to the associated `.prf` file under PVS's default name `<formula_name>-1`,
where `<formula-name>` reperesents the name of the theorem or lemma.

## Problem C.1:
### Part a:

We firstly define a type `Candidate` with 5 possible values to represent candidates. Note that adding or removing candidates can be 
done and the proofs should still hold. Next, we define type `Tally` as a function from by changing this type, no other changes to 
the theory should be necessary, candidates to `nat` to store the tally of each candidate. We define `tally_plus` to add two tallies
together.

Next, we define the inductive type `VoteSequence` to store a sequence of votes. It has two constructors, `Null` makes an empty 
sequence and `Vote` adds a vote to an existing sequence.

Now, we define some functions related to `VoteSequence` that will become useful later. `size` returns the size of a `VoteSequence`
inductively. `concat` concatenates two `VoteSequence`s.

We firstly assert that the only `VoteSequence` with size 0 is `Null` in the lemma `Size_0_Null`. We prove this by induction on
`v`, where as the base case has the same antecedent and consequent formula, it is automatially handled. For the inductive case,
the antecedent will have an expression of the form `size(Vote(...)) = 0` which when rewritten with the definition of `(size)`
will reduce to the form `1 + ... = 0`, which is a contradiction. This rewrite can be performed by `(assert)`, and this
completes the proof.

We state the lemma `Concat_Size` to express that the size of the concatenation of two `VoteSequence`s will be the sum of their 
sizes. We prove this by inducting on the second sequence by `(induct)`, and as each case can be proved by direct rewrites,
`(assert)` suffices.

We define `tally_null` to represent the 0 `Tally` and `tally_cand(c)` to represent the `Tally` where `c: Candidate` has recieved
a singel vote, and no one else has recieved a vote. We define functon `tally_sum` to add two tallies together, the addition is done
point wise. The recursive function `tally_votes` calculates the tally of each candidate in a given vote sequence.

We now define the lemma `Concat_Tally` to state that the tallies of concatenated vote sequences are the sum of the tallies of the
sequences. To prove this, we remove quantifications via `(skosimp*)` and apply `(extensionality)` to reduce the functional equation
to a simplified form. Then, we regeneralize with `(generalize-skolem-constants)` and start induction with `(induct)`. Now, for each
case, a combination of `(assert)` and `(rewrite)` suffices.

Our algorithm acts iteratively by updating a counter and a `Candidate` variable by reading one vote at a time. We capture this
behavior by defining the recursive fucntion `majority` which takes a `VoteSequence` and inductively returns the state of the 
algorithm after acting on this sequence. We define the state of the algorithm in the datatype `State`, which is just a pair of
`Candidate` and `nat`. We initially set the candidate tracker to `A`, changing this to any candidate should not invalidate any
proof.

Now, we define `majority` to take the `State` returned by `maj` and give a `Candidate`.

### Part b:

The correctness of the algorithm is stated by the theorem `Majority_Correct`. A candidate has majority if he has more than half the
votes, that is, if in the vote sequence twice his tally is more than size of the sequence. So, given that this happens, if our
algorithm is correct, it should return this candidate. This is what the theorem captures.

### Part c:

To prove `Majority_Correct`, we prove a series of lemmas and invariants. To do this, we must track certain extra states through 
`maj`. These will not affect the computation, but will help us to express invariants. To do this, we redefine a copy of `maj`
as `maj2` with extra stases. The `State2` datatype represents `maj_ext`'s state, with `c2` and `n2` being copies of `c` and
`n`. `vz` tracks the subsequence of the vote sequence since the last time 0 was encountered to to the current vote, including
the vote before which the counter was 0 for the last time, and `vr` tracks the rest of the vote sequence upto that point. We
capture this inductively by adding the last vote `vz` and keeping `vr` the same if the last vote did not make the counter 0, else
we make `vz` `Null` and concatenate all it's contents along with the last vote to `vr`.

The first thing we prove is the lemma `Maj_Maj2_Equiv` which states that the candidate and counter tracked by `maj` and `maj2`
are the same at all times. We prove this by first initiating induction using `(induct)`. For the two base cases generated,
we rewrite with `(assert)` to complete the proof. For the inductive case, using `(skosimp*)` to remove quantifications and
implications, we use `(smash)` to automatically case split, rewrite and complete the proof.

Next, we prove the lemma `Maj2_Concat`, which states that the two `VoteSequence`s being tracked in the extended state when
concatenated gives the original `VoteSequence`. We do this by `(induct v)`, and the base case is handled by rewriting with
`(assert)`. For the inductive case, we use `(skosimp*)` to remove quantifications and implications. Then, we must case split
based on if the counter becomes 0, and in each case rewriting with the definitions of `maj2` and `concat` suffices. As the
case split is apparent from the `IF` in the definition of `maj2`, it is automatically handled by `(smash)`, and `(smash)`
completes the proof.

Now, we prove the lemma `Maj2_0_Vz_Null` which states that if the counter returned by `maj2` is 0, then `vz` returned by it
must be null. We prove this by induction. The base case can be proven by direct rewrites, and `(assert)` suffices. For the
induction case, we case split based on the `IF` in the definition of `maj2`. For all cases other than the last `ELSE`, we
must have a contradiction, as the counter cannot be zero after the vote. In the last `ELSE` case, rewriting gives us that the
output for `vz` must be `NULL`. Thus, using `(smash)`, we can automatically perform the case splits, reductions and rewrites
to conclude the proof.

Our proof strategy is to emulate the proof submitted in Assignment 1, and we see that in that proof in one case, we talk about
the stretch of latestmost votes where a single candidate was being tracked and argue about the majority for this stretch. This 
stretch, in our case, is `vz`, and to argue the about the majority, we prove our first invariant  `Maj2_Inv1`, which states that 
for all `v: VoteSequence`, the candidate tracked at the end of the sequence leads over all other candidates combined by the value
of the counter at that point.

We prove this by using `(induct v)`. The base case involves direct rewriting as all conditionals in all definitions are resolved,
and `(assert)` should suffice.

For the inductive case, we must case split based on the `IF` condition within `maj2`, and we do this and simplify in a single step
using `(smash)`. In the first case we have that the counter before the last vote was 0, and we apply `Maj2_0_Vz_Null` to rewrite 
the `vz` before the last vote to `Null` in the consequent, and rewrite directly using `(assert)` to complete the proof. Since in
the other cases all conditionals are fully resolved, direct rewriting will prove the sequent, and the `(smash)` used to split the
cases should handle these cases automatically.

Now we wish to prove our correctness theorem by strong induction over the size of `VoteSequence`. To do this, we define the lemma
`Maj2_Inv` which says that for all natural number `N`, and for all `v: VoteSequence` of size at most `N`, and for all `c: Candidate`,
if `c` holds a majority in `v`, we must have that `c2(maj2(v)) = c`. Then, proving this formula by induction on `N` is essencially
performing strong induction on the size of 
